**[返回](Shell_script.md)**


# 面向新手的zsh完整教程：从入门到实用

# 前言：新手必知的zsh基础认知

## 1.1 什么是zsh？

zsh是一款功能强大的终端shell（命令行解释器），兼容bash（大多数系统默认shell）的所有核心功能，同时新增了大量人性化特性，比如：
- 智能自动补全（文件名、命令、参数都能补全）
- 灵活的语法扩展（更简洁的条件判断、循环写法）
- 自定义性强（可通过函数、配置文件打造专属终端）
新手友好提示：学习zsh无需从零开始，先掌握和bash通用的核心语法，再逐步熟悉zsh的专属功能即可。

## 1.2 如何使用zsh？
1. 切换到zsh：终端输入`zsh`（若未安装，macOS可通过 `brew install zsh` 安装，Linux可通过 `sudo apt install zsh` 安装）
2. 验证是否切换成功：输入 `echo $SHELL`，输出 `/bin/zsh` 即为成功
3. 退出zsh回到bash：输入 `bash`

# 第二章：zsh核心语法（新手必学，兼容bash）

核心语法是编写命令、脚本和函数的基础，本节按“变量→条件判断→循环→命令替换”的顺序讲解，每个知识点包含“语法规则+示例+注意事项”。

## 2.1 变量：给数据起个“名字”

变量用于存储字符串、数字等数据，方便后续调用和修改，是zsh中最基础的元素。
### 2.1.1 变量的定义规则

- 变量名由字母、数字、下划线组成，不能以数字开头（如 `name` 合法，`1name` 非法）
- 定义时 `=` 两边必须无空格（新手最易踩坑！）
- 变量无需声明类型（字符串、数字直接赋值即可）
### 2.1.2 变量的基础使用（定义+调用）

示例（直接在终端敲，实时看效果）：

```zsh
# 1. 定义变量
name="zsh新手"  # 字符串变量（可加引号，也可不加，含空格必须加引号）
age=20          # 数字变量
address="北京市 朝阳区"  # 含空格的字符串，必须加引号

# 2. 调用变量：变量名前加 $，推荐用 ${变量名} 避免歧义
echo "我的名字：$name"        # 基础用法，输出：我的名字：zsh新手
echo "我的年龄：${age}岁"     # 推荐用法，避免和后续字符混淆（比如 ${age}岁 不会被识别为 $age岁）
echo "我的地址：${address}"   # 含空格的变量必须用 ${} 调用，否则会报错
```

### 2.1.3 新手常用的变量扩展（zsh增强功能）

zsh在bash基础上扩展了变量的实用用法，比如设置默认值、替换字符、删除字符，新手掌握这3个能大幅提升效率。

```zsh
# 1. 设置默认值：变量未定义时，显示默认内容（格式：${变量名:-默认值}）
echo "我的性别：${gender:-未知}"  # gender未定义，输出：我的性别：未知
gender="男"
echo "我的性别：${gender:-未知}"  # gender已定义，输出：我的性别：男

# 2. 替换字符：替换变量中的指定字符串（格式：${变量名/旧字符/新字符}）
str="我喜欢bash"
echo "${str/bash/zsh}"  # 替换第一个bash为zsh，输出：我喜欢zsh
echo "${str//喜欢/热爱}" # 双斜杠表示全局替换（所有“喜欢”都换成“热爱”）

# 3. 删除字符：删除变量中的指定字符（格式：${变量名//要删除的字符/}）
file_name="note.txt.bak"
echo "${file_name%.bak}"  # 删除末尾的.bak，输出：note.txt（新手常用：去除文件后缀）
echo "${file_name//./}"   # 删除所有点，输出：notetxtbak
```

### 2.1.4 系统内置变量（新手直接用）

zsh自带一些常用变量，无需定义可直接调用，新手记3个最常用的：

```zsh
echo "当前zsh版本：${ZSH_VERSION}"  # 输出zsh版本，比如 5.9
echo "当前登录用户：${USER}"         # 输出你的用户名，比如 xxx
echo "当前所在目录：${PWD}"          # 输出当前终端的文件夹路径，比如 /Users/xxx/Desktop
echo "命令历史记录：${HISTFILE}"     # 输出历史命令保存的文件路径
```

### 2.1.5 新手注意事项

1. 定义变量时，等号两边不能有空格！比如 `name = "test"` 会报错，正确是 `name="test"`；
2. 变量值含空格时，必须加引号（单引号或双引号都可以），否则zsh会把空格后的内容当新命令；
3. 调用变量时，尽量用 `${变量名}` 而非 `$变量名`，避免和后续字符混淆（比如 `$age岁` 会被识别为变量 `$age岁`，导致报错）。

## 2.2 条件判断：满足条件才执行命令

条件判断用于实现“分支逻辑”，比如“如果文件存在就编辑，不存在就创建”“如果数字大于60就提示及格”。zsh推荐用 `[[ ]]`（比bash的 `[ ]` 更简单，支持正则、无需转义），数值比较用 `(( ))`。

### 2.2.1 基础语法结构

```zsh
# 单分支：满足条件执行
if [[ 条件表达式 ]]; then
    要执行的命令
fi

# 双分支：满足条件执行A，不满足执行B
if [[ 条件表达式 ]]; then
    命令A
else
    命令B
fi

# 多分支：多个条件依次判断
if [[ 条件1 ]]; then
    命令1
elif [[ 条件2 ]]; then
    命令2
else
    命令3
fi
```

新手提示：`if` 和`fi` 是一对（fi是if的反向拼写），不能遗漏；`then` 可写在 `if` 行末尾（加 ; 分隔），也可单独换行。

### 2.2.2 3类常用条件表达式（新手必记）

条件表达式是判断的核心，新手重点掌握“文件判断”“字符串判断”“数值判断”3类，用表格整理更清晰：

|判断类型|表达式写法|含义|示例|
|---|---|---|---|
|文件判断|-f $文件|判断是否为普通文件（非目录、非链接）|[[ -f note.txt ]]|
|-d $目录|判断是否为目录|[[ -d Desktop ]]|
|-e $路径|判断路径是否存在（文件/目录都可）|[[ -e ~/Documents ]]|
|字符串判断|$str1 == $str2|判断两个字符串是否相等|[[ "zsh" == "bash" ]]|
|-z $str|判断字符串是否为空|[[ -z $empty_str ]]|
|$str =~ 正则|判断字符串是否匹配正则（zsh特色）|[[ "123" =~ ^[0-9]+$ ]]（判断纯数字）|
|数值判断|$a -eq $b|a等于b（eq=equal）|(( 10 -eq 20 )) 或 [[ 10 -eq 20 ]]|
|$a -gt $b|a大于b（gt=greater than）|(( 20 -gt 10 ))|
|$a -lt $b|a小于b（lt=less than）|(( 10 -lt 20 ))|
|$a -ge $b|a大于等于b（ge=greater or equal）|(( 20 -ge 20 ))|

### 2.2.3 新手实战示例

#### 示例1：文件存在性判断（日常最常用）

```zsh
# 需求：判断桌面的note.txt是否存在，存在则查看内容，不存在则创建
file="$HOME/Desktop/note.txt"  # $HOME是用户主目录，等价于 ~

if [[ -f $file ]]; then
    echo "文件存在，正在查看内容..."
    cat $file  # 查看文件内容
else
    echo "文件不存在，正在创建..."
    touch $file  # 创建文件
    echo "这是新创建的笔记文件" > $file  # 向文件写入内容
fi
```

#### 示例2：正则判断（验证输入是否为纯数字）

```zsh
# 需求：让用户输入一个数字，验证是否合法
echo "请输入一个数字："
read num  # 读取用户输入的内容，存入num变量

if [[ $num =~ ^[0-9]+$ ]]; then
    echo "输入正确！你输入的数字是：$num"
else
    echo "输入错误！请输入纯数字。"
fi
```

#### 示例3：数值比较（判断考试分数是否及格）

```zsh
# 需求：定义分数，判断是否及格（60分及以上）
score=75

# 数值比较推荐用 (( ))，写法更简洁（无需写 -eq/-gt 等）
if (( score >= 60 )); then
    echo "恭喜！你的分数是 $score，及格了～"
else
    echo "加油！你的分数是 $score，未及格。"
fi
```

## 2.3 循环：重复执行同一组命令

循环用于“重复执行某段命令”，比如“遍历当前目录所有文件”“重复打印5次文字”。新手重点掌握 `for` 循环（遍历场景）和 `while` 循环（条件循环场景）。

### 2.3.1 for循环：遍历列表/文件（最常用）

语法：`for 变量名 in 要遍历的列表; do 命令; done`

#### 示例1：遍历固定列表

```zsh
# 需求：遍历3个shell名称，依次打印
for shell in zsh bash sh; do
    echo "当前遍历的shell：$shell"
done

# 执行结果：
# 当前遍历的shell：zsh
# 当前遍历的shell：bash
# 当前遍历的shell：sh
```

#### 示例2：遍历文件（新手日常实用）

```zsh
# 需求：遍历当前目录所有.txt文件，打印文件名和行数
for file in *.txt; do
    # 先判断是否真的存在txt文件（避免目录下无txt时，*.txt被当作普通字符串）
    [[ -f $file ]] || continue  # 不是文件就跳过
    
    line_count=$(wc -l < $file)  # 统计文件行数
    echo "$file 的行数：$line_count"
done
```

#### 示例3：zsh特色：递归遍历子目录文件

zsh支持用 `**` 递归遍历所有子目录下的文件，新手处理多层文件夹时很实用：

```zsh
# 需求：递归遍历当前目录及所有子目录下的.md文件
for file in **/*.md; do
    [[ -f $file ]] || continue
    echo "找到Markdown文件：$file"
done
```

### 2.3.2 while循环：满足条件就重复执行

语法：`while 条件表达式; do 命令; done`（条件为真时，持续执行命令）

#### 示例1：计数循环（打印1到5）

```zsh
# 需求：从1数到5，每数一个打印一次
count=1  # 初始化计数器

while (( count <= 5 )); do
    echo "当前计数：$count"
    (( count++ ))  # 计数器自增1（等价于 count = count + 1）
done
```

#### 示例2：读取文件内容（逐行读取）

```zsh
# 需求：逐行读取note.txt的内容，打印每一行
file="$HOME/Desktop/note.txt"

# 先判断文件是否存在
if [[ ! -f $file ]]; then
    echo "文件 $file 不存在"
    exit 1  # 退出脚本
fi

# 逐行读取文件内容
while read line; do
    echo "文件内容：$line"
done < $file  # < $file 表示从file文件读取内容，而非终端输入
```

### 2.3.3 新手注意事项

1. 遍历文件时，一定要加 `[[ -f $file ]] || continue`，避免目录下无对应文件时，通配符（如 *.txt）被当作普通字符串处理；
2. while循环的条件表达式要确保能终止（比如计数器自增），否则会陷入无限循环（按 Ctrl+C 可终止）；
3. 递归遍历用 `**` 时，zsh默认开启该功能，若不生效，可输入 `setopt globstar` 开启。

## 2.4 命令替换：把命令结果存到变量里

命令替换用于将“命令的执行结果”作为值，存入变量或直接使用，新手常用格式：`$(命令)`（比bash的反引号 `` 更易读，支持嵌套）。

### 2.4.1 基础示例

```zsh
# 示例1：获取当前目录路径，存入变量
current_dir=$(pwd)
echo "当前目录：$current_dir"

# 示例2：统计文件行数，直接打印结果
echo "note.txt 的行数：$(wc -l < $HOME/Desktop/note.txt)"

# 示例3：嵌套使用（获取当前目录下的txt文件个数）
txt_count=$(ls -l *.txt | wc -l)
echo "当前目录下的txt文件个数：$txt_count"
```

### 2.4.2 新手实用场景：获取系统信息

```zsh
# 需求：获取当前系统的CPU核心数、内存使用情况
cpu_core=$(sysctl -n hw.ncpu)  # macOS获取CPU核心数
# linux获取CPU核心数：cpu_core=$(grep -c ^processor /proc/cpuinfo)

mem_usage=$(free -h | grep Mem | awk '{print $3 "/" $2}')  # Linux获取内存使用
# macOS获取内存使用：mem_usage=$(top -l 1 -s 0 | grep PhysMem | awk '{print $2 "/" $4}')

echo "CPU核心数：$cpu_core"
echo "内存使用情况：$mem_usage"
```

# 第三章：zsh函数教程：把常用命令“打包”（提升效率核心）

函数是zsh的核心实用功能，用于将“重复执行的一组命令”封装成一个“自定义指令”，比如把“cd到桌面+ls查看文件”封装成 `cdDesk`，以后敲一个命令就能执行，大幅节省时间。

## 3.1 函数的基础定义与调用

### 3.1.1 两种定义格式（新手推荐第一种）

```zsh
# 格式1：简洁版（推荐，新手易记）
函数名() {
    # 函数体：要封装的一组命令
    命令1
    命令2
}

# 格式2：完整版（用function关键字，和格式1等价）
function 函数名 {
    命令1
    命令2
}
```

### 3.1.2 第一个函数：快速跳转到桌面

```zsh
# 定义函数：cdDesk，功能是跳转到桌面并查看文件
cdDesk() {
    cd $HOME/Desktop  # 跳转到桌面目录
    ls -l             # 以列表形式查看桌面文件
}

# 调用函数：直接输入函数名（无需加括号）
cdDesk
```

执行效果：终端会直接跳转到桌面，并显示桌面所有文件的详细信息。

### 3.1.3 新手注意事项
- 函数名的命名规则和变量一致（字母、数字、下划线，不以数字开头）；
- 函数体中的命令要写绝对路径（比如 `cd $HOME/Desktop` 而非 `cd 桌面`），避免切换目录后执行失败；
- 调用函数时，直接写函数名即可，不用加括号（比如 `cdDesk` 正确，`cdDesk()` 错误）。
## 3.2 带参数的函数：让函数更灵活

基础函数只能执行固定命令，带参数的函数可以根据“输入的参数”执行不同操作，比如“传入文件名就能查看行数”“传入目录名就能跳转到对应目录”。

### 3.2.1 函数参数的核心规则

zsh中，函数的参数无需声明，直接通过以下符号获取（新手记前4个即可）：

|符号|含义|示例（调用函数：func a b c）|
|---|---|---|
|$1|第一个参数|$1 = a|
|$2|第二个参数|$2 = b|
|$@|所有参数（保留空格，按原样传递）|$@ = "a" "b" "c"|
|$#|参数的个数|$# = 3|
|$0|函数名（脚本中是脚本名）|$0 = func|

### 3.2.2 实战示例1：查看指定文件的行数

```zsh
# 定义函数：fileLine，参数1为文件名，功能是查看该文件的行数
fileLine() {
    # 第一步：检查是否传入了参数（参数个数是否为1）
    if (( $# != 1 )); then
        echo "用法错误！正确用法：$0 文件名"
        echo "示例：$0 note.txt"
        return 1  # 退出函数，返回错误码（非0表示失败）
    fi

    # 第二步：检查文件是否存在
    local file=$1  # 用local定义局部变量，仅函数内有效（新手必学）
    if [[ ! -f $file ]]; then
        echo "错误：文件 $file 不存在！"
        return 1
    fi

    # 第三步：统计行数并输出
    local line_count=$(wc -l < $file)
    echo "$file 的行数：$line_count"
    return 0  # 退出函数，返回成功码（0表示成功）
}

# 调用示例
fileLine note.txt  # 正确，输出：note.txt 的行数：xxx
fileLine          # 错误，输出用法提示
fileLine a.txt b.txt  # 错误，参数个数过多
```

### 3.2.3 实战示例2：创建带名称的笔记文件

```zsh
# 定义函数：newNote，参数1为笔记名称，功能是创建.md笔记并打开
newNote() {
    # 检查参数个数
    if (( $# != 1 )); then
        echo "用法错误！正确用法：$0 笔记名称"
        echo "示例：$0 今日学习笔记"
        return 1
    fi

    # 定义笔记路径（桌面目录下的.md文件）
    local note_name=$1
    local note_path="$HOME/Desktop/$note_name.md"

    # 检查文件是否已存在，避免覆盖
    if [[ -f $note_path ]]; then
        echo "错误：笔记 $note_path 已存在！"
        return 1
    fi

    # 创建文件并写入默认内容
    touch $note_path
    echo "# $note_name" > $note_path  # 写入标题
    echo "创建成功！笔记路径：$note_path"

    # 打开文件（macOS用open，Linux用xdg-open，Windows用start）
    open $note_path
}

# 调用示例
newNote 今日学习笔记  # 会在桌面创建“今日学习笔记.md”并打开
```

## 3.3 新手必学：函数的局部变量（避免污染全局环境）

在函数中用 `local` 定义的变量是“局部变量”，仅在函数内部有效；不加 `local` 的变量是“全局变量”，会影响函数外部的环境（新手容易踩坑）。

### 示例：局部变量vs全局变量

```zsh
testVar() {
    global_var="我是全局变量"  # 全局变量，函数外也能访问
    local local_var="我是局部变量"  # 局部变量，仅函数内有效

    echo "函数内 - 全局变量：$global_var"
    echo "函数内 - 局部变量：$local_var"
}

# 调用函数
testVar

# 函数外访问变量
echo "函数外 - 全局变量：$global_var"  # 能访问，输出：我是全局变量
echo "函数外 - 局部变量：$local_var"  # 不能访问，输出空（未定义）
```

新手提示：函数内的变量一定要加 `local` 定义！否则会导致全局变量混乱，比如函数内的 `count` 变量会覆盖外部的 `count` 变量。

## 3.4 函数的永久保存：关掉终端也能使用

直接在终端定义的函数，关掉终端后就会消失。新手需要把常用函数保存到zsh的配置文件 `~/.zshrc` 中，实现永久生效。

### 具体步骤（新手一步一步来）
1. 打开配置文件：终端输入 `vim ~/.zshrc`（vim是终端编辑器，新手也可用文本编辑器打开：`open ~/.zshrc`（macOS）或 `xdg-open ~/.zshrc`（Linux））
2. 添加函数：在文件末尾粘贴写好的函数（比如 `cdDesk`、`fileLine`、`newNote`）
3. 保存文件：
    1. vim编辑器：按 `Esc` 键，输入 `:wq`（w=保存，q=退出），按回车；
    2. 文本编辑器：直接点保存即可。
4. 让配置生效：终端输入 `source ~/.zshrc`（无需重启终端，立即生效）

验证：关掉当前终端，重新打开，直接输入 `cdDesk`，若能跳转到桌面，说明函数已永久生效。

## 3.5 新手实用函数合集（直接抄）

```zsh
# 1. 快速跳转到工作目录（替换为你的工作目录路径）
cdWork() {
    local work_dir="$HOME/Documents/工作"
    if [[ -d $work_dir ]]; then
        cd $work_dir
        ls -l
    else
        echo "错误：工作目录 $work_dir 不存在！"
    fi
}

# 2. 批量重命名：把当前目录的.txt文件改为.md文件
renameTxtToMd() {
    # 先检查是否有txt文件
    local txt_files=(*.txt)
    if [[ ! -f ${txt_files[0]} ]]; then
        echo "当前目录没有.txt文件！"
        return 1
    fi

    # 批量重命名
    for file in *.txt; do
        local new_file="${file%.txt}.md"  # 去除.txt后缀，添加.md
        mv "$file" "$new_file"
        echo "重命名成功：$file → $new_file"
    done
}

# 3. 查看指定端口的占用情况（比如查看8080端口）
checkPort() {
    if (( $# != 1 )); then
        echo "用法错误！正确用法：$0 端口号"
        echo "示例：$0 8080"
        return 1
    fi

    local port=$1
    # lsof -i :端口号 查看端口占用，2>/dev/null 忽略错误输出
    lsof -i :$port 2>/dev/null || echo "$port 端口未被占用"
}
```

# 第四章：新手实操练习（巩固知识点）

学习语法和函数后，通过以下练习加深理解，新手建议逐题完成：

## 练习1：变量与变量扩展

需求：定义一个变量 `file_path="$HOME/Desktop/test.txt"`，完成以下操作：
1. 打印变量的值，格式：“文件路径：xxx”；
2. 用变量扩展，获取该文件的文件名（test.txt），打印：“文件名：xxx”；
3. 用变量扩展，获取该文件的目录路径（$HOME/Desktop），打印：“目录路径：xxx”。

## 练习2：条件判断

需求：判断 `$HOME/Desktop/test.txt` 是否存在，存在则打印文件行数，不存在则创建文件并写入“这是测试文件”。

## 练习3：循环

需求：遍历 `$HOME/Desktop` 目录下所有文件，区分“普通文件”和“目录”，分别打印：“文件：xxx”和“目录：xxx”。

## 练习4：函数

需求：定义一个函数 `delEmptyFile`，功能是删除当前目录下所有空文件（大小为0的文件），要求：
1. 先检查当前目录是否有空文件；
2. 删除空文件前，打印要删除的文件名；
3. 删除完成后，打印“共删除x个空文件”。
# 第五章：新手常见问题与解决方案

## 问题1：定义变量时，等号加空格报错

错误写法：`name = "test"` → 报错：zsh: command not found: name
解决方案：等号两边无空格，正确写法：`name="test"`

## 问题2：函数调用时，提示“command not found”

原因：1. 函数名拼写错误；2. 函数未保存到 `~/.zshrc` 或未执行 `source ~/.zshrc`；3. 函数定义有语法错误（比如缺少 `{` 或 `}`）。
解决方案：1. 检查函数名拼写；2. 重新执行 `source ~/.zshrc`；3. 检查函数定义的语法（比如 `()` 和 `{}` 是否配对）。

## 问题3：循环遍历文件时，出现“*.txt: No such file or directory”

原因：目录下无对应文件，通配符 `*.txt` 被当作普通字符串处理。
解决方案：在循环内添加判断，跳过非文件：`[[ -f $file ]] || continue`

## 问题4：函数内的变量影响了外部变量

原因：函数内的变量未加 `local` 定义，是全局变量。
解决方案：函数内所有变量都用 `local` 定义，比如 `local count=1`。